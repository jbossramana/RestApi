Introduction to the @Async Feature
======================

The @Async feature in Spring is designed to execute a method in a separate thread, freeing 
up the main thread (usually the web server's thread) to immediately send a response back to 
the client. This is essential for preventing client timeouts and improving the overall concurrency 
of the application.

1. The Problem: Blocking the Web Thread 
==========================

The Scenario: If a client sends a POST request to generate a large report, and that report takes 
10 seconds to process, the web thread handling that request is blocked for the entire duration.

The Consequence: While the thread is blocked, it cannot handle other incoming requests. 
If the thread pool is exhausted, new clients will experience delays or even connection timeouts, 
leading to a poor user experience.

2. The Solution: Spring's @Async 
=====================

The Role of @Async: By annotating a service method (like ReportService.generateReportAsync()) 
with @Async, you instruct Spring to delegate the execution of that method to a separate, 
managed thread pool (the Task Executor).

Non-Blocking Execution: The JobController calls the ReportService.initiateReportGeneration() 
method. Inside, the call to the @Async method returns immediately to the controller, even 
though the report generation has only just begun.

Enabling @Async: The feature requires the presence of the @EnableAsync annotation, 
typically placed on your main Spring Boot application class, to activate the asynchronous behavior.


1. Initiate the Job (POST):

Send a POST request to http://localhost:8080/api/v1/jobs/reports
|_ Add the header -> X-User-ID = any user-id

Get the polling Location header (e.g., http://localhost:8080/api/v1/jobs/{jobId}).


2. Poll Status (GET):

Send a GET request to the polling URL (http://localhost:8080/api/v1/jobs/{jobId}).

When the job is complete, Postman will show the 303 See Other response.

Crucially, Postman will display the final download URL in the response header (Location header). Copy this URL.


3. Get the File Content (Final GET):

Send a GET request to the final download URL (e.g., http://localhost:8080/api/v1/jobs/reports/{jobId}/download).

Postman's response body will directly display the content of the file (the text string "Report ID: {jobId} ...").


* Run the last  url from browser to download the file



Real-time use cases:
=============

1. Large Report Generation (Business Intelligence) ðŸ“Š
This is the most direct application of your example.

Scenario: A user initiates the generation of a complex monthly sales report, an audit log for the last year, 
or a financial reconciliation file. These tasks involve querying millions of records across multiple databases, 
which can take several minutes.

API Flow:

Client POST: Request to /reports with date range.

Server Response: Immediately replies with 202 Accepted and a Location header to /jobs/{report_id}.

Client Polls: The frontend or background task continuously polls the /jobs/{report_id} endpoint.

Final Result: Once complete, the polling endpoint redirects the client to /reports/{report_id}/download, 
where the final PDF or CSV file is retrieved.

